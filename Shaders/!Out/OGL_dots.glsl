{
 "fragment": "#version 330\r\nstruct vec1 {\r\n\tfloat x;\r\n};\r\nstruct uvec1 {\r\n\tuint x;\r\n};\r\nstruct ivec1 {\r\n\tint x;\r\n};\r\n in  vec4 Color1;\r\nvec4 Input1;\r\n in  vec4 quadCoord0;\r\nvec4 Input2;\r\nlayout(location = 0) out  vec4 SV_Target0;\r\n#define Output0 SV_Target0\r\nvec4 Temp[1];\r\nivec4 Temp_int[1];\r\nuvec4 Temp_uint[1];\r\nvoid main()\r\n{\r\n    Input1 = Color1;\r\n    Input2 = quadCoord0;\r\n    Temp[0].x = dot(Input2.xy, Input2.xy);\r\n    Temp[0].x = sqrt(Temp[0].x);\r\n    Temp[0].x = Temp[0].x + intBitsToFloat(int(0xBF19999A));\r\n    Temp[0].x = min(abs(Temp[0].x), intBitsToFloat(0x3F800000));\r\n    Temp[0].x = (-Temp[0].x) + intBitsToFloat(0x3F8CCCCD);\r\n    Temp[0].x = log2(Temp[0].x);\r\n    Temp[0].x = Temp[0].x * intBitsToFloat(int(0x41200000));\r\n    Output0.w = exp2(Temp[0].x);\r\n    Output0.xyz = Input1.xyz;\r\n    return;\r\n}\r\n",
 "vertex": "#version 330\r\nstruct vec1 {\r\n\tfloat x;\r\n};\r\nstruct uvec1 {\r\n\tuint x;\r\n};\r\nstruct ivec1 {\r\n\tint x;\r\n};\r\nuniform \tmat4 VP_Matrix;\r\nuniform \tmat4 V_Matrix;\r\nuniform \tmat4 P_Matrix;\r\nuniform \tmat4 VP_InverseMatrix;\r\nuniform \tmat4 V_InverseMatrix;\r\nuniform \tmat4 P_InverseMatrix;\r\nuniform \tvec2 PixelSize;\r\nuniform \tfloat Rad;\r\nuniform \tvec2 FiModifier;\r\n in  vec4 in_quadCoord0;\r\nvec4 Input0;\r\n in  vec4 in_vsCoord0;\r\nvec4 Input1;\r\n in  vec4 in_vsColor1;\r\nvec4 Input2;\r\n#undef Output0\r\n#define Output0 phase0_Output0\r\nvec4 phase0_Output0;\r\n out  vec4 Color1;\r\n#define Output1 Color1\r\n out  vec4 quadCoord0;\r\n#define Output2 quadCoord0\r\nvec4 Temp[2];\r\nivec4 Temp_int[2];\r\nuvec4 Temp_uint[2];\r\nvoid main()\r\n{\r\n    Input0 = in_quadCoord0;\r\n    Input1 = in_vsCoord0;\r\n    Input2 = in_vsColor1;\r\n    Temp[0].x = Input1.z * FiModifier.xyxx.x;\r\n    Temp[0].x = FiModifier.xyxx.y * Temp[0].x + Input1.z;\r\n    Temp[1].x = cos(Temp[0].x);\r\n    Temp[0].x = sin(Temp[0].x);\r\n    Temp[1].y = Temp[0].x;\r\n    Temp[0].xy = Rad * Temp[1].xy + Input0.xy;\r\n    Temp[1] = Input1.yyyy * VP_Matrix[1];\r\n    Temp[1] = VP_Matrix[0] * Input1.xxxx + Temp[1];\r\n    Temp[1] = Temp[1] + VP_Matrix[3];\r\n    Temp[0].zw = Temp[1].xy \/ Temp[1].ww;\r\n    Temp[0].xy = PixelSize.xyxx.xy * Temp[0].xy + Temp[0].zw;\r\n    Output0.xy = Temp[1].ww * Temp[0].xy;\r\n    Output0.zw = Temp[1].zw;\r\n    Output1 = Input2;\r\n    Output2.xy = Input0.xy;\r\n    gl_Position = vec4(phase0_Output0);\r\n    return;\r\n}\r\n",
 "name": "OGL_dots"
}