{
 "Vertex": "#version 330\r\n#extension GL_ARB_texture_query_levels : enable\r\nstruct vec1 {\r\n\tfloat x;\r\n};\r\nstruct uvec1 {\r\n\tuint x;\r\n};\r\nstruct ivec1 {\r\n\tint x;\r\n};\r\nuniform \tmat4 M_Matrix;\r\nuniform \tmat4 MVP_Matrix;\r\nuniform \tmat4 MV_Matrix;\r\nuniform \tmat4 P_Matrix;\r\nuniform \tmat4 M_InverseMatrix;\r\nuniform \tmat4 MVP_InverseMatrix;\r\nuniform \tmat4 MV_InverseMatrix;\r\nuniform \tmat4 P_InverseMatrix;\r\nuniform \tmat4 VP_Matrix;\r\nuniform \tmat4 VP_InverseMatrix;\r\nuniform \tmat4 V_Matrix;\r\nuniform \tmat4 V_InverseMatrix;\r\nuniform \tvec2 FBOFlip;\r\nuniform sampler2D BoneTransform;\r\nuniform sampler2D Materials;\r\n in  vec4 in_vsCoord0;\r\nvec4 Input0;\r\n in  vec4 in_vsNormal0;\r\nvec4 Input1;\r\n in  vec4 in_vsTex0;\r\nvec4 Input2;\r\n in  vec4 in_vsMatIndex0;\r\nvec4 Input3;\r\n in  vec4 in_vsWIndex0;\r\nvec4 Input4;\r\n in  vec4 in_vsWeight0;\r\nvec4 Input5;\r\n in  vec4 in_aiBoneMatDifNormOffset0;\r\nvec4 Input6;\r\n#undef Output0\r\n#define Output0 phase0_Output0\r\nvec4 phase0_Output0;\r\n out  vec4 vCoord0;\r\n#define Output1 vCoord0\r\n out  vec4 vNorm0;\r\n#define Output2 vNorm0\r\n out  vec4 vTex0;\r\n#define Output3 vTex0\r\n out  vec4 Diffuse0;\r\n#define Output4 Diffuse0\r\n out  vec4 Specular0;\r\n#define Output5 Specular0\r\n out  vec4 DiffK_SpecPow_MapInd0;\r\n#define Output6 DiffK_SpecPow_MapInd0\r\nvec4 Temp[10];\r\nivec4 Temp_int[10];\r\nuvec4 Temp_uint[10];\r\nvoid main()\r\n{\r\n    Input0 = in_vsCoord0;\r\n    Input1 = in_vsNormal0;\r\n    Input2 = in_vsTex0;\r\n    Input3 = in_vsMatIndex0;\r\n    Input4 = in_vsWIndex0;\r\n    Input5 = in_vsWeight0;\r\n    Input6 = in_aiBoneMatDifNormOffset0;\r\n    Temp[0] = Input4 + Input6.xxxx;\r\n    Temp[1] = Temp[0] * vec4(intBitsToFloat(int(0x40800000)), intBitsToFloat(int(0x40800000)), intBitsToFloat(int(0x40800000)), intBitsToFloat(int(0x40800000)));\r\n    Temp[0] = uintBitsToFloat(uvec4(greaterThanEqual(Temp[0], vec4(intBitsToFloat(0x0), intBitsToFloat(0x0), intBitsToFloat(0x0), intBitsToFloat(0x0)))) * 0xFFFFFFFFu);\r\n    if((floatBitsToUint(Temp[0]).x)!=0u){\r\n        Temp[2].x = (vec2(textureSize(BoneTransform, 0x0)).x);\r\n        Temp[2].y = (vec2(textureSize(BoneTransform, 0x0)).y);\r\n        Temp[2].z = (0.0);\r\n        Temp[2].w = float(textureQueryLevels(BoneTransform));\r\n        Temp[2].zw = vec2(intBitsToFloat(0x3F800000), intBitsToFloat(0x3F800000)) \/ Temp[2].xy;\r\n        Temp[0].x = Temp[1].x \/ Temp[2].x;\r\n        Temp[3].z = fract(Temp[0].x);\r\n        Temp[0].x = trunc(Temp[0].x);\r\n        Temp[3].w = Temp[0].x \/ Temp[2].y;\r\n        Temp[3].zw = Temp[2].zw * vec2(intBitsToFloat(0x3F000000), intBitsToFloat(0x3F000000)) + Temp[3].zw;\r\n        Temp[4] = textureLod(BoneTransform, Temp[3].zw, intBitsToFloat(0x0)).wxyz;\r\n        Temp[3].y = Temp[2].z + Temp[3].z;\r\n        Temp[5] = textureLod(BoneTransform, Temp[3].yw, intBitsToFloat(0x0));\r\n        Temp[3].x = Temp[2].z * intBitsToFloat(int(0x40000000)) + Temp[3].z;\r\n        Temp[2] = textureLod(BoneTransform, Temp[3].xw, intBitsToFloat(0x0));\r\n        Temp[3].xyz = Temp[4].yzw * Input5.xxx;\r\n        Temp[4].y = Temp[5].w;\r\n        Temp[4].z = Temp[2].w;\r\n        Temp[4].xyz = Temp[4].xyz * Input5.xxx;\r\n        Temp[5].xyz = Temp[5].xyz * Input5.xxx;\r\n        Temp[2].xyz = Temp[2].xyz * Input5.xxx;\r\n    } else {\r\n        Temp[3].xyz = vec3(intBitsToFloat(0x3F800000), intBitsToFloat(0x0), intBitsToFloat(0x0));\r\n        Temp[5].xyz = vec3(intBitsToFloat(0x0), intBitsToFloat(0x3F800000), intBitsToFloat(0x0));\r\n        Temp[2].xyz = vec3(intBitsToFloat(0x0), intBitsToFloat(0x0), intBitsToFloat(0x3F800000));\r\n        Temp[4].xyz = vec3(intBitsToFloat(0x0), intBitsToFloat(0x0), intBitsToFloat(0x0));\r\n    \/\/ENDIF\r\n    }\r\n    if((floatBitsToUint(Temp[0]).y)!=0u){\r\n        Temp[6].x = (vec2(textureSize(BoneTransform, 0x0)).x);\r\n        Temp[6].y = (vec2(textureSize(BoneTransform, 0x0)).y);\r\n        Temp[6].z = (0.0);\r\n        Temp[6].w = float(textureQueryLevels(BoneTransform));\r\n        Temp[0].xy = vec2(intBitsToFloat(0x3F800000), intBitsToFloat(0x3F800000)) \/ Temp[6].xy;\r\n        Temp[1].x = Temp[1].y \/ Temp[6].x;\r\n        Temp[6].z = fract(Temp[1].x);\r\n        Temp[1].x = trunc(Temp[1].x);\r\n        Temp[6].w = Temp[1].x \/ Temp[6].y;\r\n        Temp[6].zw = Temp[0].xy * vec2(intBitsToFloat(0x3F000000), intBitsToFloat(0x3F000000)) + Temp[6].zw;\r\n        Temp[7] = textureLod(BoneTransform, Temp[6].zw, intBitsToFloat(0x0));\r\n        Temp[6].y = Temp[0].x + Temp[6].z;\r\n        Temp[8] = textureLod(BoneTransform, Temp[6].yw, intBitsToFloat(0x0));\r\n        Temp[6].x = Temp[0].x * intBitsToFloat(int(0x40000000)) + Temp[6].z;\r\n        Temp[6] = textureLod(BoneTransform, Temp[6].xw, intBitsToFloat(0x0));\r\n        Temp[9].x = Temp[7].w;\r\n        Temp[9].y = Temp[8].w;\r\n        Temp[9].z = Temp[6].w;\r\n        Temp[3].xyz = Temp[7].xyz * Input5.yyy + Temp[3].xyz;\r\n        Temp[4].xyz = Temp[9].xyz * Input5.yyy + Temp[4].xyz;\r\n        Temp[5].xyz = Temp[8].xyz * Input5.yyy + Temp[5].xyz;\r\n        Temp[2].xyz = Temp[6].xyz * Input5.yyy + Temp[2].xyz;\r\n    \/\/ENDIF\r\n    }\r\n    if((floatBitsToUint(Temp[0]).z)!=0u){\r\n        Temp[6].x = (vec2(textureSize(BoneTransform, 0x0)).x);\r\n        Temp[6].y = (vec2(textureSize(BoneTransform, 0x0)).y);\r\n        Temp[6].z = (0.0);\r\n        Temp[6].w = float(textureQueryLevels(BoneTransform));\r\n        Temp[0].xy = vec2(intBitsToFloat(0x3F800000), intBitsToFloat(0x3F800000)) \/ Temp[6].xy;\r\n        Temp[0].z = Temp[1].z \/ Temp[6].x;\r\n        Temp[6].z = fract(Temp[0].z);\r\n        Temp[0].z = trunc(Temp[0].z);\r\n        Temp[6].w = Temp[0].z \/ Temp[6].y;\r\n        Temp[6].zw = Temp[0].xy * vec2(intBitsToFloat(0x3F000000), intBitsToFloat(0x3F000000)) + Temp[6].zw;\r\n        Temp[7] = textureLod(BoneTransform, Temp[6].zw, intBitsToFloat(0x0));\r\n        Temp[6].y = Temp[0].x + Temp[6].z;\r\n        Temp[8] = textureLod(BoneTransform, Temp[6].yw, intBitsToFloat(0x0));\r\n        Temp[6].x = Temp[0].x * intBitsToFloat(int(0x40000000)) + Temp[6].z;\r\n        Temp[6] = textureLod(BoneTransform, Temp[6].xw, intBitsToFloat(0x0));\r\n        Temp[0].x = Temp[7].w;\r\n        Temp[0].y = Temp[8].w;\r\n        Temp[0].z = Temp[6].w;\r\n        Temp[3].xyz = Temp[7].xyz * Input5.zzz + Temp[3].xyz;\r\n        Temp[4].xyz = Temp[0].xyz * Input5.zzz + Temp[4].xyz;\r\n        Temp[5].xyz = Temp[8].xyz * Input5.zzz + Temp[5].xyz;\r\n        Temp[2].xyz = Temp[6].xyz * Input5.zzz + Temp[2].xyz;\r\n    \/\/ENDIF\r\n    }\r\n    if((floatBitsToUint(Temp[0]).w)!=0u){\r\n        Temp[0].x = (vec2(textureSize(BoneTransform, 0x0)).x);\r\n        Temp[0].y = (vec2(textureSize(BoneTransform, 0x0)).y);\r\n        Temp[0].z = (0.0);\r\n        Temp[0].w = float(textureQueryLevels(BoneTransform));\r\n        Temp[0].zw = vec2(intBitsToFloat(0x3F800000), intBitsToFloat(0x3F800000)) \/ Temp[0].xy;\r\n        Temp[0].x = Temp[1].w \/ Temp[0].x;\r\n        Temp[1].z = fract(Temp[0].x);\r\n        Temp[0].x = trunc(Temp[0].x);\r\n        Temp[1].w = Temp[0].x \/ Temp[0].y;\r\n        Temp[1].zw = Temp[0].zw * vec2(intBitsToFloat(0x3F000000), intBitsToFloat(0x3F000000)) + Temp[1].zw;\r\n        Temp[6] = textureLod(BoneTransform, Temp[1].zw, intBitsToFloat(0x0));\r\n        Temp[1].y = Temp[0].z + Temp[1].z;\r\n        Temp[7] = textureLod(BoneTransform, Temp[1].yw, intBitsToFloat(0x0));\r\n        Temp[1].x = Temp[0].z * intBitsToFloat(int(0x40000000)) + Temp[1].z;\r\n        Temp[0] = textureLod(BoneTransform, Temp[1].xw, intBitsToFloat(0x0));\r\n        Temp[1].x = Temp[6].w;\r\n        Temp[1].y = Temp[7].w;\r\n        Temp[1].z = Temp[0].w;\r\n        Temp[3].xyz = Temp[6].xyz * Input5.www + Temp[3].xyz;\r\n        Temp[1].xyz = Temp[1].xyz * Input5.www + Temp[4].xyz;\r\n        Temp[5].xyz = Temp[7].xyz * Input5.www + Temp[5].xyz;\r\n        Temp[2].xyz = Temp[0].xyz * Input5.www + Temp[2].xyz;\r\n        Temp[3].w = Temp[1].x;\r\n        Temp[5].w = Temp[1].y;\r\n        Temp[2].w = Temp[1].z;\r\n    } else {\r\n        Temp[3].w = Temp[4].x;\r\n        Temp[5].w = Temp[4].y;\r\n        Temp[2].w = Temp[4].z;\r\n    \/\/ENDIF\r\n    }\r\n    Temp[0].xyz = Input0.xyz;\r\n    Temp[0].w = intBitsToFloat(0x3F800000);\r\n    Temp[1].x = dot(Temp[3], Temp[0]);\r\n    Temp[1].y = dot(Temp[5], Temp[0]);\r\n    Temp[0].x = dot(Temp[2], Temp[0]);\r\n    Temp[3].x = dot(Temp[3].xyz, Input1.xyz);\r\n    Temp[3].y = dot(Temp[5].xyz, Input1.xyz);\r\n    Temp[3].z = dot(Temp[2].xyz, Input1.xyz);\r\n    Temp[0].yzw = Temp[1].yyy * V_Matrix[1].xyz;\r\n    Temp[0].yzw = V_Matrix[0].xyz * Temp[1].xxx + Temp[0].yzw;\r\n    Temp[0].xyz = V_Matrix[2].xyz * Temp[0].xxx + Temp[0].yzw;\r\n    Temp[0].xyz = Temp[0].xyz + V_Matrix[3].xyz;\r\n    Temp[0].w = dot(Temp[3].xyz, Temp[3].xyz);\r\n    Temp[0].w = inversesqrt(Temp[0].w);\r\n    Temp[1].xyz = Temp[0].www * Temp[3].xyz;\r\n    Temp[2].xyz = Temp[1].yyy * V_Matrix[1].xyz;\r\n    Temp[1].xyw = V_Matrix[0].xyz * Temp[1].xxx + Temp[2].xyz;\r\n    Output2.xyz = V_Matrix[2].xyz * Temp[1].zzz + Temp[1].xyw;\r\n    Temp[1] = Temp[0].yyyy * P_Matrix[1];\r\n    Temp[1] = P_Matrix[0] * Temp[0].xxxx + Temp[1];\r\n    Temp[1] = P_Matrix[2] * Temp[0].zzzz + Temp[1];\r\n    Output0 = Temp[1] + P_Matrix[3];\r\n    Temp[1].xyz = Input3.xxx + Input6.yzw;\r\n    Temp[2].x = (vec2(textureSize(Materials, 0x0)).x);\r\n    Temp[2].y = (vec2(textureSize(Materials, 0x0)).y);\r\n    Temp[2].z = (0.0);\r\n    Temp[2].w = float(textureQueryLevels(Materials));\r\n    Temp[2].xy = vec2(intBitsToFloat(0x3F800000), intBitsToFloat(0x3F800000)) \/ Temp[2].xy;\r\n    Temp[3].x = Temp[1].x + intBitsToFloat(0x3F000000);\r\n    Temp[3].yzw = vec3(intBitsToFloat(0x3F000000), intBitsToFloat(0x3FC00000), intBitsToFloat(int(0x40200000)));\r\n    Temp[4] = Temp[2].xyxy * Temp[3].yxzx;\r\n    Output4 = textureLod(Materials, Temp[4].xy, intBitsToFloat(0x0));\r\n    Output5 = textureLod(Materials, Temp[4].zw, intBitsToFloat(0x0));\r\n    Temp[1].xw = Temp[2].xy * Temp[3].wx;\r\n    Temp[2] = textureLod(Materials, Temp[1].xw, intBitsToFloat(0x0));\r\n    Output6.xy = Temp[2].xy;\r\n    Output6.zw = Temp[1].yz;\r\n    Output1.xyz = Temp[0].xyz;\r\n    Output3.xy = Input2.xy;\r\n    gl_Position = vec4(phase0_Output0);\r\n    return;\r\n}\r\n",
 "Fragment": "#version 330\r\nstruct vec1 {\r\n\tfloat x;\r\n};\r\nstruct uvec1 {\r\n\tuint x;\r\n};\r\nstruct ivec1 {\r\n\tint x;\r\n};\r\nuniform sampler2DArray Maps;\r\n in  vec4 vCoord0;\r\nvec4 Input1;\r\n in  vec4 vNorm0;\r\nvec4 Input2;\r\n in  vec4 vTex0;\r\nvec4 Input3;\r\n in  vec4 Diffuse0;\r\nvec4 Input4;\r\n in  vec4 DiffK_SpecPow_MapInd0;\r\nvec4 Input6;\r\nlayout(location = 0) out  vec4 SV_Target0;\r\n#define Output0 SV_Target0\r\nvec4 Temp[2];\r\nivec4 Temp_int[2];\r\nuvec4 Temp_uint[2];\r\nvoid main()\r\n{\r\n    Input1 = vCoord0;\r\n    Input2 = vNorm0;\r\n    Input3 = vTex0;\r\n    Input4 = Diffuse0;\r\n    Input6 = DiffK_SpecPow_MapInd0;\r\n    Temp[0].x = dot(Input2.xyz, Input2.xyz);\r\n    Temp[0].x = inversesqrt(Temp[0].x);\r\n    Temp[0].xyz = Temp[0].xxx * Input2.xyz;\r\n    Temp[0].w = dot(Input1.xyz, Input1.xyz);\r\n    Temp[0].w = inversesqrt(Temp[0].w);\r\n    Temp[1].xyz = Temp[0].www * Input1.xyz;\r\n    Temp[0].x = dot((-Temp[0].xyz), Temp[1].xyz);\r\n    Temp[0].x = max(Temp[0].x, intBitsToFloat(0x0));\r\n    Temp[1].xy = Input3.xy;\r\n    Temp[1].z = Input6.z;\r\n    Temp[1] = texture(Maps, Temp[1].xyz);\r\n    Temp[1] = Temp[1] + (-Input4);\r\n    Temp[1] = Input6.xxxx * Temp[1] + Input4;\r\n    Output0.xyz = Temp[1].xyz * Temp[0].xxx + vec3(intBitsToFloat(0x3E99999A), intBitsToFloat(0x3E99999A), intBitsToFloat(0x3E99999A));\r\n    Output0.w = Temp[1].w;\r\n    return;\r\n}\r\n",
 "Name": "avMesh"
}