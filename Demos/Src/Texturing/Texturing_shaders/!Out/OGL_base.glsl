{
 "fragment": "#version 330\r\nstruct vec1 {\r\n\tfloat x;\r\n};\r\nstruct uvec1 {\r\n\tuint x;\r\n};\r\nstruct ivec1 {\r\n\tint x;\r\n};\r\n in  vec4 Normal0;\r\nvec4 Input1;\r\nlayout(location = 0) out  vec4 SV_Target0;\r\n#define Output0 SV_Target0\r\nvec4 Temp[1];\r\nivec4 Temp_int[1];\r\nuvec4 Temp_uint[1];\r\nvoid main()\r\n{\r\n    Input1 = Normal0;\r\n    Temp[0].x = dot(Input1.xyz, Input1.xyz);\r\n    Temp[0].x = inversesqrt(Temp[0].x);\r\n    Temp[0].x = Temp[0].x * Input1.z;\r\n    Output0 = max((-Temp[0].xxxx), vec4(intBitsToFloat(0x0), intBitsToFloat(0x0), intBitsToFloat(0x0), intBitsToFloat(0x0)));\r\n    return;\r\n}\r\n",
 "vertex": "#version 330\r\nstruct vec1 {\r\n\tfloat x;\r\n};\r\nstruct uvec1 {\r\n\tuint x;\r\n};\r\nstruct ivec1 {\r\n\tint x;\r\n};\r\nuniform \tmat4 M_Matrix;\r\nuniform \tmat4 MVP_Matrix;\r\nuniform \tmat4 MV_Matrix;\r\nuniform \tmat4 P_Matrix;\r\nuniform \tmat4 M_InverseMatrix;\r\nuniform \tmat4 MVP_InverseMatrix;\r\nuniform \tmat4 MV_InverseMatrix;\r\nuniform \tmat4 P_InverseMatrix;\r\nuniform \tmat4 VP_Matrix;\r\nuniform \tmat4 VP_InverseMatrix;\r\nuniform \tmat4 V_Matrix;\r\nuniform \tmat4 V_InverseMatrix;\r\n in  vec4 in_vsCoord0;\r\nvec4 Input0;\r\n in  vec4 in_vsNormal0;\r\nvec4 Input1;\r\n#undef Output0\r\n#define Output0 phase0_Output0\r\nvec4 phase0_Output0;\r\n out  vec4 Normal0;\r\n#define Output1 Normal0\r\nvec4 Temp[1];\r\nivec4 Temp_int[1];\r\nuvec4 Temp_uint[1];\r\nvoid main()\r\n{\r\n    Input0 = in_vsCoord0;\r\n    Input1 = in_vsNormal0;\r\n    Temp[0] = Input0.yyyy * VP_Matrix[1];\r\n    Temp[0] = VP_Matrix[0] * Input0.xxxx + Temp[0];\r\n    Temp[0] = VP_Matrix[2] * Input0.zzzz + Temp[0];\r\n    Output0 = Temp[0] + VP_Matrix[3];\r\n    Temp[0].xyz = Input1.yyy * V_Matrix[1].xyz;\r\n    Temp[0].xyz = V_Matrix[0].xyz * Input1.xxx + Temp[0].xyz;\r\n    Output1.xyz = V_Matrix[2].xyz * Input1.zzz + Temp[0].xyz;\r\n    gl_Position = vec4(phase0_Output0);\r\n    return;\r\n}\r\n",
 "name": "OGL_base"
}