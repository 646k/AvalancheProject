{
 "Vertex": "#version 330\r\nstruct vec1 {\r\n\tfloat x;\r\n};\r\nstruct uvec1 {\r\n\tuint x;\r\n};\r\nstruct ivec1 {\r\n\tint x;\r\n};\r\nuniform \tmat4 UIMatrix;\r\nuniform \tmat4 UIMatrixInverse;\r\nuniform \tvec2 ViewPortSize;\r\nuniform \tfloat PixelToUnit;\r\n in  vec4 in_quadCoord0;\r\nvec4 Input0;\r\n in  vec4 in_Coords0;\r\nvec4 Input1;\r\n in  vec4 in_Normals0;\r\nvec4 Input2;\r\n in  vec4 in_Width0;\r\nvec4 Input3;\r\n in  vec4 in_HintingAlign0;\r\nvec4 Input4;\r\n#undef Output0\r\n#define Output0 phase0_Output0\r\nvec4 phase0_Output0;\r\n out  vec4 Color1;\r\n#define Output1 Color1\r\nvec4 Temp[5];\r\nivec4 Temp_int[5];\r\nuvec4 Temp_uint[5];\r\nvoid main()\r\n{\r\n    Input0 = in_quadCoord0;\r\n    Input1 = in_Coords0;\r\n    Input2 = in_Normals0;\r\n    Input3 = in_Width0;\r\n    Input4 = in_HintingAlign0;\r\n    Temp[0].xyz = uintBitsToFloat(uvec3(notEqual(vec4(intBitsToFloat(0x0), intBitsToFloat(0x0), intBitsToFloat(0x0), intBitsToFloat(0x0)), Input4.zxyz).xyz) * 0xFFFFFFFFu);\r\n    if((floatBitsToUint(Temp[0]).x)==0u){\r\n        Temp[1] = Input1.yyyy * UIMatrix[1];\r\n        Temp[1] = Input1.xxxx * UIMatrix[0] + Temp[1];\r\n        Temp[1] = Temp[1] + UIMatrix[3];\r\n        Temp[1].xyz = Temp[1].xyz \/ Temp[1].www;\r\n        Temp[2].xy = Temp[1].xy + vec2(intBitsToFloat(0x3F800000), intBitsToFloat(0x3F800000));\r\n        Temp[2].zw = ViewPortSize.xyxx.xy * vec2(intBitsToFloat(0x3F000000), intBitsToFloat(0x3F000000));\r\n        Temp[2].xy = Temp[2].zw * Temp[2].xy;\r\n        Temp[3].xy = uintBitsToFloat(uvec2(notEqual(vec4(intBitsToFloat(0x0), intBitsToFloat(0x0), intBitsToFloat(0x0), intBitsToFloat(0x0)), Input4.xyxx).xy) * 0xFFFFFFFFu);\r\n        Temp[3].zw = roundEven(Temp[2].xy);\r\n        Temp[2].x = (floatBitsToInt(Temp[3]).x != 0) ? Temp[3].z : Temp[2].x;\r\n        Temp[2].y = (floatBitsToInt(Temp[3]).y != 0) ? Temp[3].w : Temp[2].y;\r\n        Temp[2].xy = Temp[2].xy \/ Temp[2].zw;\r\n        Temp[1].xy = Temp[2].xy + vec2(intBitsToFloat(int(0xBF800000)), intBitsToFloat(int(0xBF800000)));\r\n        Temp[1].xyz = Temp[1].www * Temp[1].xyz;\r\n        Temp[2].xy = Temp[1].yy * UIMatrixInverse[1].xy;\r\n        Temp[1].xy = Temp[1].xx * UIMatrixInverse[0].xy + Temp[2].xy;\r\n        Temp[1].xy = Temp[1].zz * UIMatrixInverse[2].xy + Temp[1].xy;\r\n        Temp[1].xy = Temp[1].ww * UIMatrixInverse[3].xy + Temp[1].xy;\r\n        Temp[4] = Input1.wwww * UIMatrix[1];\r\n        Temp[4] = Input1.zzzz * UIMatrix[0] + Temp[4];\r\n        Temp[4] = Temp[4] + UIMatrix[3];\r\n        Temp[4].xyz = Temp[4].xyz \/ Temp[4].www;\r\n        Temp[1].zw = Temp[4].xy + vec2(intBitsToFloat(0x3F800000), intBitsToFloat(0x3F800000));\r\n        Temp[1].zw = Temp[2].zw * Temp[1].zw;\r\n        Temp[2].xy = roundEven(Temp[1].zw);\r\n        Temp[1].z = (floatBitsToInt(Temp[3]).x != 0) ? Temp[2].x : Temp[1].z;\r\n        Temp[1].w = (floatBitsToInt(Temp[3]).y != 0) ? Temp[2].y : Temp[1].w;\r\n        Temp[1].zw = Temp[1].zw \/ Temp[2].zw;\r\n        Temp[4].xy = Temp[1].zw + vec2(intBitsToFloat(int(0xBF800000)), intBitsToFloat(int(0xBF800000)));\r\n        Temp[2].xyz = Temp[4].www * Temp[4].xyz;\r\n        Temp[1].zw = Temp[2].yy * UIMatrixInverse[1].xy;\r\n        Temp[1].zw = Temp[2].xx * UIMatrixInverse[0].xy + Temp[1].zw;\r\n        Temp[1].zw = Temp[2].zz * UIMatrixInverse[2].xy + Temp[1].zw;\r\n        Temp[1].zw = Temp[4].ww * UIMatrixInverse[3].xy + Temp[1].zw;\r\n    } else {\r\n        Temp[1] = Input1;\r\n    \/\/ENDIF\r\n    }\r\n    Temp[1].zw = (-Temp[1].xy) + Temp[1].zw;\r\n    Temp[1].xy = Input0.xx * Temp[1].zw + Temp[1].xy;\r\n    Temp[1].zw = (-Input2.xy) + Input2.zw;\r\n    Temp[1].zw = Input0.xx * Temp[1].zw + Input2.xy;\r\n    Temp[0].w = Input3.y * PixelToUnit;\r\n    Temp[0].w = max(Temp[0].w, Input3.x);\r\n    Temp[0].w = Temp[0].w * intBitsToFloat(0x3F000000);\r\n    Temp[1].zw = Temp[0].ww * Temp[1].zw;\r\n    Temp[0].w = Input0.y + Input4.w;\r\n    Temp[1].xy = Temp[1].zw * Temp[0].ww + Temp[1].xy;\r\n    Temp[1].yzw = Temp[1].yyy * UIMatrix[1].xyw;\r\n    Temp[1].xyz = Temp[1].xxx * UIMatrix[0].xyw + Temp[1].yzw;\r\n    Temp[1].xyz = Temp[1].xyz + UIMatrix[3].xyw;\r\n    Temp[2].xy = Temp[1].xy \/ Temp[1].zz;\r\n    Temp[2].xy = Temp[2].xy + vec2(intBitsToFloat(0x3F800000), intBitsToFloat(0x3F800000));\r\n    Temp[2].zw = ViewPortSize.xyxx.xy * vec2(intBitsToFloat(0x3F000000), intBitsToFloat(0x3F000000));\r\n    Temp[2].xy = Temp[2].zw * Temp[2].xy;\r\n    Temp[3].xy = roundEven(Temp[2].xy);\r\n    Temp[0].y = (floatBitsToInt(Temp[0]).y != 0) ? Temp[3].x : Temp[2].x;\r\n    Temp[0].z = (floatBitsToInt(Temp[0]).z != 0) ? Temp[3].y : Temp[2].y;\r\n    Temp[0].yz = Temp[0].yz \/ Temp[2].zw;\r\n    Temp[0].yz = Temp[0].yz + vec2(intBitsToFloat(int(0xBF800000)), intBitsToFloat(int(0xBF800000)));\r\n    Temp[0].yz = Temp[1].zz * Temp[0].yz;\r\n    Output0.xy = (floatBitsToInt(Temp[0]).xxxx.x != 0) ? Temp[0].yz : Temp[1].xy;\r\n    Output0.z = intBitsToFloat(0x3F000000);\r\n    Output0.w = Temp[1].z;\r\n    Output1 = vec4(intBitsToFloat(0x3F800000), intBitsToFloat(0x3F800000), intBitsToFloat(0x3F800000), intBitsToFloat(0x3F800000));\r\n    gl_Position = vec4(phase0_Output0);\r\n    return;\r\n}\r\n",
 "Fragment": "#version 330\r\nstruct vec1 {\r\n\tfloat x;\r\n};\r\nstruct uvec1 {\r\n\tuint x;\r\n};\r\nstruct ivec1 {\r\n\tint x;\r\n};\r\nlayout(location = 0) out  vec4 SV_Target0;\r\n#define Output0 SV_Target0\r\nvoid main()\r\n{\r\n    Output0 = vec4(intBitsToFloat(0x3F800000), intBitsToFloat(0x3F800000), intBitsToFloat(0x3F800000), intBitsToFloat(0x3F800000));\r\n    return;\r\n}\r\n",
 "Name": "CanvasLine"
}